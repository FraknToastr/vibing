<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pattern Extractor</title>
  <style>
    :root {
      --bg: #0f172a;
      --bg-grad-a: #0b1022;
      --bg-grad-b: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22c55e;
      --warn: #f59e0b;
      --error: #ef4444;
      --line: #374151;
      --square: 2.2rem;
      --radius: 10px;
      --font: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Light theme tokens are activated when data-theme="light" is present on <html>. */
    :root[data-theme="light"] {
      --bg: #eef2ff;
      --bg-grad-a: #f8fafc;
      --bg-grad-b: #e2e8f0;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #0f172a;
      --muted: #475569;
      --accent: #16a34a;
      --warn: #d97706;
      --error: #dc2626;
      --line: #cbd5e1;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: linear-gradient(180deg, var(--bg-grad-a), var(--bg-grad-b) 40%);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
    }

    .container {
      width: min(1200px, 96vw);
      margin: 1rem auto 2rem;
      display: grid;
      gap: 1rem;
    }

    .card {
      background: color-mix(in srgb, var(--panel) 95%, transparent);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 0.9rem;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    }

    h1 {
      margin: 0;
      font-size: 1.3rem;
      letter-spacing: 0.2px;
    }

    h2 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      color: color-mix(in srgb, var(--text) 85%, #6366f1 15%);
      font-weight: 650;
    }

    .subtle {
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 0.35rem;
      line-height: 1.35;
    }

    .usage {
      margin: 0.6rem 0 0;
      padding-left: 1.1rem;
      color: #d1d5db;
      line-height: 1.4;
      font-size: 0.92rem;
    }

    .controls,
    .toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 0.7rem;
      align-items: center;
    }

    .toggles {
      margin-top: 0.5rem;
    }

    .field {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.9rem;
      color: #dbeafe;
      background: var(--panel-2);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 0.35rem 0.45rem;
    }

    label { user-select: none; }

    input[type="number"],
    input[type="text"],
    select,
    textarea,
    button {
      font: inherit;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      background: #0b1220;
      color: var(--text);
      border: 1px solid #334155;
      border-radius: 6px;
      padding: 0.36rem 0.45rem;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      resize: vertical;
      font-family: var(--mono);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    button {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid color-mix(in srgb, var(--line) 80%, #475569 20%);
      border-radius: 8px;
      padding: 0.45rem 0.7rem;
      cursor: pointer;
      transition: transform .04s ease, background .15s ease;
    }

    button:hover { background: #334155; }
    button:active { transform: translateY(1px); }
    button.primary { background: #14532d; border-color: #22c55e; }
    button.primary:hover { background: #166534; }

    .pattern-rows {
      display: grid;
      gap: 0.65rem;
      margin-top: 0.4rem;
    }

    .pattern-row {
      border: 1px solid color-mix(in srgb, var(--line) 80%, transparent);
      border-radius: 8px;
      padding: 0.5rem;
      background: color-mix(in srgb, var(--panel-2) 82%, transparent);
    }

    .pattern-row-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
    }

    .pattern-row-title {
      font-size: 0.82rem;
      color: var(--muted);
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }

    .row-wrap {
      overflow-x: auto;
      padding-bottom: 0.2rem;
    }

    .pattern-grid {
      min-width: 1080px;
      display: grid;
      grid-template-columns: repeat(20, minmax(var(--square), var(--square)));
      gap: 0.35rem;
      align-items: end;
      justify-content: start;
    }

    .cell {
      display: grid;
      gap: 0.2rem;
      justify-items: center;
      transition: opacity .15s ease;
    }

    .cell.inactive {
      opacity: 1;
    }

    select.type-select {
      width: var(--square);
      height: 1.25rem;
      padding: 0;
      text-align: center;
      font-size: 0.74rem;
      background: #b59f3b;
      color: #ffffff;
      border-color: #9c8933;
    }

    input.char-input {
      width: var(--square);
      height: var(--square);
      text-align: center;
      text-transform: none;
      font-size: 1rem;
      font-weight: 650;
      font-family: var(--mono);
      padding: 0;
      border-radius: 7px;
      border: 1px solid #9c8933;
      background: #b59f3b;
      color: #ffffff;
    }

    .cell.configured select.type-select {
      background: #538d4e;
      border-color: #467a42;
      color: #ffffff;
    }

    .cell.configured input.char-input {
      background: #538d4e;
      border-color: #467a42;
      color: #ffffff;
    }

    input.char-input.invalid {
      border-color: var(--error);
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.22);
      background: rgba(127, 29, 29, 0.25);
    }

    .status {
      min-height: 1.2rem;
      margin-top: 0.35rem;
      font-size: 0.92rem;
      color: #bae6fd;
    }

    .status.error { color: #fecaca; }
    .status.ok { color: #86efac; }

    .counter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 0.35rem;
      color: #cbd5e1;
      font-size: 0.88rem;
    }

    .counter code {
      color: #fef08a;
      font-family: var(--mono);
    }

    :root[data-theme="light"] .field { color: #0f172a; }
    :root[data-theme="light"] .subtle { color: #475569; }
    :root[data-theme="light"] .usage { color: #1e293b; }
    :root[data-theme="light"] textarea,
    :root[data-theme="light"] input[type="text"],
    :root[data-theme="light"] input[type="number"],
    :root[data-theme="light"] select {
      background: #ffffff;
      border-color: #94a3b8;
      color: #0f172a;
    }
    :root[data-theme="light"] select.type-select {
      background: #c9b458;
      color: #ffffff;
      border-color: #ad9a48;
    }
    :root[data-theme="light"] input.char-input {
      background: #c9b458;
      border-color: #ad9a48;
      color: #ffffff;
    }
    :root[data-theme="light"] .cell.configured select.type-select {
      background: #6aaa64;
      border-color: #5b9556;
      color: #ffffff;
    }
    :root[data-theme="light"] .cell.configured input.char-input {
      background: #6aaa64;
      border-color: #5b9556;
      color: #ffffff;
    }
    :root[data-theme="light"] .counter { color: #334155; }
    :root[data-theme="light"] .counter code { color: #854d0e; }

    @media (max-width: 760px) {
      .container { width: 98vw; }
      .field { font-size: 0.84rem; }
      textarea { min-height: 130px; }
    }
  </style>
</head>
<body>
  <main class="container">
    <section class="card">
      <h1>Wordle-Style Pattern Extractor (Offline)</h1>
      <p class="subtle">Extracts matching substrings from pasted text using one or more 20-position pattern rows.</p>
      <ol class="usage">
        <li>Paste text, set pattern type + optional char in each square, then click <strong>Extract</strong>.</li>
        <li>Use <strong>Add Another Pattern</strong> to create alternate rows (for example DNNNN and FNNNN).</li>
        <li>Keep <strong>Length</strong> in Auto, or set manually (1–20) to force extraction length.</li>
        <li>Use output options for quoting, dedupe, trim, and CSV row formatting.</li>
      </ol>
    </section>

    <section class="card">
      <h2>Pattern (20 positions)</h2>
      <div class="controls">
        <label class="field">
          Pattern preset
          <select id="presetSelect">
            <option value="">Custom</option>
            <option value="asseticId">Assetic Id</option>
            <option value="pathwayId">Pathway Id</option>
            <option value="planSaId">Plan SA Id</option>
            <option value="pathwayUbn">Pathway UBN</option>
            <option value="auMobile">Australian Mobile (2 patterns)</option>
            <option value="auMedicare">Australian Medicare Number (3 patterns)</option>
            <option value="auAbn">Australian ABN (2 patterns)</option>
            <option value="auTfn">Australian Tax File Number (3 patterns)</option>
          </select>
        </label>
        <label class="field">
          <input id="lengthAuto" type="checkbox" checked />
          Length Auto
        </label>
        <label class="field">
          Length (1–20)
          <input id="manualLength" type="number" min="1" max="20" value="20" disabled />
        </label>
        <button id="resetPatternBtn" type="button">Reset Pattern</button>
        <button id="sampleBtn" type="button">Sample Input</button>
        <button id="addPatternRowBtn" type="button">Add Another Pattern</button>
      </div>
      <div class="subtle">Type codes per position: <strong>L</strong>=Letter, <strong>N</strong>=Number, <strong>C</strong>=Character, <strong>*</strong>=Wildcard.</div>
      <div id="patternRows" class="pattern-rows" aria-label="Pattern maker rows"></div>
      <div id="statusMsg" class="status" aria-live="polite"></div>
      <div id="counter" class="counter">
        <span>Total matches: <code id="countTotal">0</code></span>
        <span>Unique output: <code id="countUnique">0</code></span>
        <span>Time: <code id="countTime">0 ms</code></span>
        <span>Active length(s): <code id="activeLen">1</code></span>
      </div>
    </section>

    <section class="card">
      <h2>Input</h2>
      <textarea id="inputText" placeholder="Paste source text here..."></textarea>
      <div class="controls" style="margin-top:0.6rem;">
        <button id="extractBtn" class="primary" type="button">Extract</button>
        <button id="clearInputBtn" type="button">Clear Input</button>
      </div>
    </section>

    <section class="card">
      <h2>Output Options</h2>
      <div class="toggles">
        <label class="field"><input id="allowDupes" type="checkbox" /> Allow duplicates</label>
        <label class="field"><input id="trimMatches" type="checkbox" checked /> Trim matches</label>
        <label class="field"><input id="singleQuoteWrap" type="checkbox" /> Wrap each in single quotes</label>
      </div>
      <div class="toggles">
        <label class="field">
          Layout
          <select id="layoutSelect">
            <option value="singleRow">Single row (comma-separated)</option>
            <option value="singleColumnNoHeader">Single column (no header)</option>
            <option value="singleColumnWithHeader">Single column (with header)</option>
          </select>
        </label>
        <label class="field">
          Header name
          <input id="headerName" type="text" value="Extracted" placeholder="Extracted" style="width:140px;" />
        </label>
      </div>
    </section>

    <section class="card">
      <h2>Output</h2>
      <textarea id="outputText" placeholder="Extraction output appears here..."></textarea>
      <div class="controls" style="margin-top:0.6rem;">
        <button id="copyOutputBtn" type="button">Copy Output</button>
        <button id="clearOutputBtn" type="button">Clear Output</button>
      </div>
    </section>
  </main>

  <script>
    "use strict";

    // Constants for per-position selector types.
    const TYPE = {
      LETTER: "L",
      NUMBER: "N",
      CHARACTER: "C",
      WILDCARD: "*"
    };

    const TOTAL_POSITIONS = 20;

    const el = {
      patternRows: document.getElementById("patternRows"),
      addPatternRowBtn: document.getElementById("addPatternRowBtn"),
      lengthAuto: document.getElementById("lengthAuto"),
      manualLength: document.getElementById("manualLength"),
      statusMsg: document.getElementById("statusMsg"),
      countTotal: document.getElementById("countTotal"),
      countUnique: document.getElementById("countUnique"),
      countTime: document.getElementById("countTime"),
      activeLen: document.getElementById("activeLen"),
      inputText: document.getElementById("inputText"),
      outputText: document.getElementById("outputText"),
      presetSelect: document.getElementById("presetSelect"),
      allowDupes: document.getElementById("allowDupes"),
      trimMatches: document.getElementById("trimMatches"),
      singleQuoteWrap: document.getElementById("singleQuoteWrap"),
      layoutSelect: document.getElementById("layoutSelect"),
      headerName: document.getElementById("headerName"),
      extractBtn: document.getElementById("extractBtn"),
      copyOutputBtn: document.getElementById("copyOutputBtn"),
      clearInputBtn: document.getElementById("clearInputBtn"),
      clearOutputBtn: document.getElementById("clearOutputBtn"),
      resetPatternBtn: document.getElementById("resetPatternBtn"),
      sampleBtn: document.getElementById("sampleBtn")
    };

    const patternRows = [];
    let nextPatternRowId = 1;
    const PATTERN_PRESETS = {
      asseticId: { label: "Assetic Id", templates: ["NNNNNN"] },
      pathwayId: { label: "Pathway Id", templates: ["NNNNNN"] },
      planSaId: { label: "Plan SA Id", templates: ["NNNNNNNN"] },
      // Based on UBN.csv dominant format.
      pathwayUbn: { label: "Pathway UBN", templates: ["NNNN-NN-NN"] },
      auMobile: {
        label: "Australian Mobile (2 patterns)",
        templates: ["04NNNNNNNN", "+614NNNNNNNN"]
      },
      auMedicare: {
        label: "Australian Medicare Number (3 patterns)",
        templates: ["NNNNNNNNNN", "NNNN NNNNN N", "NNNN-NNNNN-N"]
      },
      auAbn: {
        label: "Australian ABN (2 patterns)",
        templates: ["NNNNNNNNNNN", "NN NNN NNN NNN"]
      },
      auTfn: {
        label: "Australian Tax File Number (3 patterns)",
        templates: ["NNNNNNNNN", "NNN NNN NNN", "NNN-NNN-NNN"]
      }
    };
    const HEADER_NAME_CUSTOM = "custom pattern";
    const HEADER_NAME_SAMPLE = "Sample";
    const THEME_STORAGE_KEY = "jrDataToolboxTheme";
    const LEGACY_THEME_STORAGE_KEY = "patternExtractorTheme";
    const THEME_MESSAGE_TYPE = "jr-toolbox-theme";

    function setTheme(theme, persist = true) {
      const resolved = theme === "light" ? "light" : "dark";
      document.documentElement.setAttribute("data-theme", resolved);
      if (persist) {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, resolved);
        } catch {
          // Ignore storage limitations in strict browser environments.
        }
      }
    }

    function initTheme() {
      let stored = "dark";
      try {
        stored =
          localStorage.getItem(THEME_STORAGE_KEY) ||
          localStorage.getItem(LEGACY_THEME_STORAGE_KEY) ||
          "dark";
      } catch {
        stored = "dark";
      }
      setTheme(stored, false);
    }

    function wireThemeMessages() {
      window.addEventListener("message", (ev) => {
        const data = ev.data;
        if (!data || typeof data !== "object") return;
        if (data.type !== THEME_MESSAGE_TYPE) return;
        setTheme(data.theme);
      });
    }

    function isLetter(ch) {
      return /^[A-Za-z]$/.test(ch);
    }

    function isDigit(ch) {
      return /^[0-9]$/.test(ch);
    }

    function charAllowedByType(ch, typeCode) {
      if (ch === "") return true;
      if (typeCode === TYPE.LETTER) return isLetter(ch);
      if (typeCode === TYPE.NUMBER) return isDigit(ch);
      return true; // Character and Wildcard allow any single char.
    }

    function setHeaderNameByPatternSource(source, presetKey = "") {
      if (source === "sample") {
        el.headerName.value = HEADER_NAME_SAMPLE;
        return;
      }
      if (source === "preset" && PATTERN_PRESETS[presetKey]) {
        el.headerName.value = PATTERN_PRESETS[presetKey].label;
        return;
      }
      el.headerName.value = HEADER_NAME_CUSTOM;
    }

    function getPresetTemplates(preset) {
      if (!preset) return [];
      if (Array.isArray(preset.templates) && preset.templates.length > 0) {
        return preset.templates;
      }
      if (typeof preset.template === "string" && preset.template !== "") {
        return [preset.template];
      }
      return [];
    }

    function refreshPatternRowHeaders() {
      const allowRemove = patternRows.length > 1;
      patternRows.forEach((row, idx) => {
        row.title.textContent = `Pattern ${idx + 1}`;
        row.removeBtn.disabled = !allowRemove;
        row.removeBtn.style.visibility = allowRemove ? "visible" : "hidden";
      });
    }

    function setRowToWildcard(row) {
      row.cells.forEach((c) => {
        c.select.value = TYPE.WILDCARD;
        c.input.value = "";
        c.input.classList.remove("invalid");
      });
    }

    function applyTemplateToRow(row, template) {
      setRowToWildcard(row);
      const tokens = (template || "").split("").slice(0, TOTAL_POSITIONS);
      tokens.forEach((token, idx) => {
        const cell = row.cells[idx];
        if (token === "N") {
          cell.select.value = TYPE.NUMBER;
          cell.input.value = "";
        } else if (token === "L") {
          cell.select.value = TYPE.LETTER;
          cell.input.value = "";
        } else if (token === "C") {
          cell.select.value = TYPE.CHARACTER;
          cell.input.value = "";
        } else if (token === "*") {
          cell.select.value = TYPE.WILDCARD;
          cell.input.value = "";
        } else if (isDigit(token)) {
          cell.select.value = TYPE.NUMBER;
          cell.input.value = token;
        } else if (isLetter(token)) {
          cell.select.value = TYPE.LETTER;
          cell.input.value = token;
        } else {
          cell.select.value = TYPE.CHARACTER;
          cell.input.value = token;
        }
      });
    }

    function createPatternRow() {
      const row = {
        id: nextPatternRowId,
        root: document.createElement("div"),
        title: document.createElement("div"),
        removeBtn: document.createElement("button"),
        cells: []
      };
      nextPatternRowId += 1;

      row.root.className = "pattern-row";
      const rowHead = document.createElement("div");
      rowHead.className = "pattern-row-head";

      row.title.className = "pattern-row-title";
      row.title.textContent = "Pattern";

      row.removeBtn.type = "button";
      row.removeBtn.textContent = "Remove";
      row.removeBtn.addEventListener("click", () => {
        if (patternRows.length <= 1) return;
        const idx = patternRows.findIndex((entry) => entry.id === row.id);
        if (idx === -1) return;
        patternRows[idx].root.remove();
        patternRows.splice(idx, 1);
        el.presetSelect.value = "";
        setHeaderNameByPatternSource("custom");
        refreshPatternRowHeaders();
        validatePattern(false);
        setStatus("Pattern removed.", "");
      });

      rowHead.appendChild(row.title);
      rowHead.appendChild(row.removeBtn);
      row.root.appendChild(rowHead);

      const rowWrap = document.createElement("div");
      rowWrap.className = "row-wrap";
      const grid = document.createElement("div");
      grid.className = "pattern-grid";
      grid.setAttribute("role", "group");
      grid.setAttribute("aria-label", "20-position pattern");
      rowWrap.appendChild(grid);
      row.root.appendChild(rowWrap);

      for (let i = 0; i < TOTAL_POSITIONS; i += 1) {
        const cell = document.createElement("div");
        cell.className = "cell";

        const select = document.createElement("select");
        select.className = "type-select";
        select.setAttribute("aria-label", `Type for pattern ${row.id}, position ${i + 1}`);
        [TYPE.LETTER, TYPE.NUMBER, TYPE.CHARACTER, TYPE.WILDCARD].forEach((code) => {
          const option = document.createElement("option");
          option.value = code;
          option.textContent = code;
          if (code === TYPE.WILDCARD) option.selected = true;
          select.appendChild(option);
        });

        const input = document.createElement("input");
        input.className = "char-input";
        input.type = "text";
        input.maxLength = 1;
        input.autocomplete = "off";
        input.spellcheck = false;
        input.setAttribute("aria-label", `Character for pattern ${row.id}, position ${i + 1}`);

        input.addEventListener("input", (ev) => {
          const v = ev.target.value;
          ev.target.value = v.length > 1 ? v.slice(0, 1) : v;
          if (ev.target.value !== "") {
            if (isDigit(ev.target.value)) {
              select.value = TYPE.NUMBER;
            } else if (isLetter(ev.target.value)) {
              select.value = TYPE.LETTER;
            } else {
              select.value = TYPE.CHARACTER;
            }
          }
          setHeaderNameByPatternSource("custom");
          validatePattern(false);
          if (ev.target.value && i < TOTAL_POSITIONS - 1) {
            row.cells[i + 1].input.focus();
            row.cells[i + 1].input.select();
          }
        });

        input.addEventListener("keydown", (ev) => {
          if (ev.key === "ArrowRight" && i < TOTAL_POSITIONS - 1) {
            ev.preventDefault();
            row.cells[i + 1].input.focus();
            row.cells[i + 1].input.select();
          } else if (ev.key === "ArrowLeft" && i > 0) {
            ev.preventDefault();
            row.cells[i - 1].input.focus();
            row.cells[i - 1].input.select();
          } else if (ev.key === "Backspace" && ev.target.value === "" && i > 0) {
            ev.preventDefault();
            row.cells[i - 1].input.focus();
            row.cells[i - 1].input.value = "";
            setHeaderNameByPatternSource("custom");
            validatePattern(false);
          }
        });

        select.addEventListener("change", () => {
          setHeaderNameByPatternSource("custom");
          validatePattern(false);
        });

        cell.appendChild(select);
        cell.appendChild(input);
        grid.appendChild(cell);
        row.cells.push({ cell, select, input });
      }

      return row;
    }

    function addPatternRow(template = "", quiet = false) {
      const row = createPatternRow();
      patternRows.push(row);
      el.patternRows.appendChild(row.root);
      if (template) applyTemplateToRow(row, template);
      refreshPatternRowHeaders();
      validatePattern(false);
      if (!quiet) {
        setStatus(`Added pattern ${patternRows.length}.`, "ok");
      }
      return row;
    }

    function clearPatternRows() {
      while (patternRows.length > 0) {
        const row = patternRows.pop();
        row.root.remove();
      }
    }

    function getActiveLengthForRow(row) {
      if (!el.lengthAuto.checked) {
        const manual = Number(el.manualLength.value);
        return Math.max(1, Math.min(TOTAL_POSITIONS, Number.isFinite(manual) ? manual : 1));
      }

      let maxIdx = 0;
      for (let i = 0; i < TOTAL_POSITIONS; i += 1) {
        const c = row.cells[i];
        const hasChar = c.input.value !== "";
        const typeNotWildcard = c.select.value !== TYPE.WILDCARD;
        if (hasChar || typeNotWildcard) maxIdx = i + 1;
      }
      return Math.max(1, maxIdx);
    }

    function applyPreset(key) {
      const preset = PATTERN_PRESETS[key];
      if (!preset) return;
      const templates = getPresetTemplates(preset).map((template) => template.slice(0, TOTAL_POSITIONS));
      if (templates.length === 0) return;

      clearPatternRows();
      templates.forEach((template) => addPatternRow(template, true));

      el.lengthAuto.checked = true;
      el.manualLength.disabled = true;
      el.manualLength.value = "20";
      setHeaderNameByPatternSource("preset", key);
      validatePattern(false);
      setStatus(`Preset applied: ${preset.label}.`, "ok");
    }

    function updateCellWordleStates() {
      patternRows.forEach((row) => {
        row.cells.forEach((c) => {
          const configured = c.input.value !== "" || c.select.value !== TYPE.WILDCARD;
          c.cell.classList.toggle("configured", configured);
        });
      });
    }

    function updateActiveLengthVisuals(activeLengths) {
      if (activeLengths.length === 0) {
        el.activeLen.textContent = "1";
        return;
      }

      el.activeLen.textContent = activeLengths.join(" | ");
      patternRows.forEach((row, rowIdx) => {
        const L = activeLengths[rowIdx] || 1;
        for (let i = 0; i < TOTAL_POSITIONS; i += 1) {
          row.cells[i].cell.classList.toggle("inactive", i >= L);
        }
      });
    }

    function setStatus(msg, kind = "") {
      el.statusMsg.textContent = msg;
      el.statusMsg.className = `status${kind ? ` ${kind}` : ""}`;
    }

    function formatInvalidLocations(invalidByRow) {
      return invalidByRow
        .map((entry) => `row ${entry.row} position(s): ${entry.positions.join(", ")}`)
        .join("; ");
    }

    // Validates entered chars against selected type; marks invalid squares.
    function validatePattern(showError = true) {
      const activeLengths = patternRows.map((row) => getActiveLengthForRow(row));
      updateActiveLengthVisuals(activeLengths);
      updateCellWordleStates();

      const invalidByRow = [];
      patternRows.forEach((row, rowIdx) => {
        const L = activeLengths[rowIdx];
        const invalidPositions = [];

        for (let i = 0; i < L; i += 1) {
          const { select, input } = row.cells[i];
          const ok = charAllowedByType(input.value, select.value);
          input.classList.toggle("invalid", !ok);
          if (!ok) invalidPositions.push(i + 1);
        }

        for (let i = L; i < TOTAL_POSITIONS; i += 1) {
          row.cells[i].input.classList.remove("invalid");
        }

        if (invalidPositions.length > 0) {
          invalidByRow.push({ row: rowIdx + 1, positions: invalidPositions });
        }
      });

      if (invalidByRow.length > 0) {
        if (showError) setStatus(`Pattern invalid at ${formatInvalidLocations(invalidByRow)}.`, "error");
        return { valid: false, invalidByRow, activeLengths };
      }

      if (showError) setStatus("Pattern valid and ready.", "ok");
      return { valid: true, invalidByRow: [], activeLengths };
    }

    // Build matcher exactly as requested.
    function buildMatcher(patternSelectors, patternChars, L) {
      const invalidPositions = [];

      for (let i = 0; i < L; i += 1) {
        if (!charAllowedByType(patternChars[i], patternSelectors[i])) {
          invalidPositions.push(i + 1);
        }
      }

      if (invalidPositions.length > 0) {
        return {
          isValid: false,
          invalidPositions,
          matchAt: () => false
        };
      }

      const matchAt = (text, index) => {
        for (let i = 0; i < L; i += 1) {
          const currentChar = text[index + i];
          const requiredType = patternSelectors[i];
          const fixedChar = patternChars[i];

          // Type constraint.
          if (requiredType === TYPE.LETTER && !isLetter(currentChar)) return false;
          if (requiredType === TYPE.NUMBER && !isDigit(currentChar)) return false;
          // Character / Wildcard => no extra type checks.

          // Optional fixed-char constraint.
          if (fixedChar !== "") {
            if (requiredType === TYPE.LETTER) {
              if (fixedChar.toLowerCase() !== currentChar.toLowerCase()) return false;
            } else if (fixedChar !== currentChar) {
              return false;
            }
          }
        }
        return true;
      };

      return { isValid: true, invalidPositions: [], matchAt };
    }

    function csvEscapeIfNeeded(value) {
      const needsQuotes = /[",\n]/.test(value);
      if (!needsQuotes) return value;
      return `"${value.replace(/"/g, '""')}"`;
    }

    function formatOutput(values) {
      const wrapQuotes = el.singleQuoteWrap.checked;
      const prepared = wrapQuotes ? values.map((v) => `'${v}'`) : values.slice();
      const layout = el.layoutSelect.value;

      if (layout === "singleRow") {
        return prepared.join(",");
      }

      const columnValues = prepared.join("\n");
      if (layout === "singleColumnNoHeader") {
        return columnValues;
      }
      if (layout !== "singleColumnWithHeader") {
        return columnValues;
      }
      const headerRaw = (el.headerName.value || "").trim() || HEADER_NAME_CUSTOM;
      const headerLine = csvEscapeIfNeeded(headerRaw);
      return `${headerLine}\n${columnValues}`;
    }

    function extractMatches() {
      const start = performance.now();
      const { valid, invalidByRow, activeLengths } = validatePattern(true);
      if (!valid) {
        setStatus(`Cannot extract: invalid pattern at ${formatInvalidLocations(invalidByRow)}.`, "error");
        el.countTotal.textContent = "0";
        el.countUnique.textContent = "0";
        el.countTime.textContent = `${Math.round(performance.now() - start)} ms`;
        return;
      }

      const text = el.inputText.value || "";
      const minLength = activeLengths.length > 0 ? Math.min(...activeLengths) : 1;
      if (text.length < minLength) {
        setStatus(`No matches: input length (${text.length}) is shorter than active length (${minLength}).`, "");
        el.outputText.value = "No patterns found.";
        el.countTotal.textContent = "0";
        el.countUnique.textContent = "0";
        el.countTime.textContent = `${Math.round(performance.now() - start)} ms`;
        return;
      }

      const matchers = [];
      for (let rowIdx = 0; rowIdx < patternRows.length; rowIdx += 1) {
        const row = patternRows[rowIdx];
        const L = activeLengths[rowIdx];
        const selectors = row.cells.map((c) => c.select.value);
        const chars = row.cells.map((c) => c.input.value);
        const matcher = buildMatcher(selectors, chars, L);
        if (!matcher.isValid) {
          setStatus(`Cannot extract: invalid pattern at row ${rowIdx + 1}, position(s): ${matcher.invalidPositions.join(", ")}.`, "error");
          return;
        }
        matchers.push({ matcher, L });
      }

      let total = 0;
      const allowDupes = el.allowDupes.checked;
      const trimOutput = el.trimMatches.checked;
      const seen = new Set();
      const values = [];

      matchers.forEach(({ matcher, L }) => {
        if (text.length < L) return;
        for (let i = 0; i <= text.length - L; i += 1) {
          if (!matcher.matchAt(text, i)) continue;
          total += 1;
          let candidate = text.slice(i, i + L);
          if (trimOutput) candidate = candidate.trim();

          if (allowDupes) {
            values.push(candidate);
          } else if (!seen.has(candidate)) {
            seen.add(candidate);
            values.push(candidate);
          }
        }
      });

      el.outputText.value = formatOutput(values);
      el.countTotal.textContent = String(total);
      el.countUnique.textContent = String(values.length);
      el.countTime.textContent = `${Math.round(performance.now() - start)} ms`;

      if (values.length === 0) {
        el.outputText.value = "No patterns found.";
        setStatus("No matches found.", "");
      } else {
        setStatus(`Extraction complete: ${values.length} value(s) from ${patternRows.length} pattern(s).`, "ok");
      }
    }

    async function copyOutput() {
      const out = el.outputText.value;
      if (!out) {
        setStatus("Output is empty; nothing to copy.", "");
        return;
      }
      try {
        await navigator.clipboard.writeText(out);
        setStatus("Output copied to clipboard.", "ok");
      } catch {
        // Clipboard may be blocked on file:// in some browsers.
        el.outputText.focus();
        el.outputText.select();
        setStatus("Clipboard unavailable here. Output selected; press Ctrl/Cmd+C.", "");
      }
    }

    function resetPattern() {
      clearPatternRows();
      addPatternRow("", true);
      el.presetSelect.value = "";
      el.lengthAuto.checked = true;
      el.manualLength.disabled = true;
      el.manualLength.value = "20";
      setHeaderNameByPatternSource("custom");
      validatePattern(false);
      setStatus("Pattern reset.", "");
    }

    function loadSample() {
      el.inputText.value = [
        "Ref IDs: AB12, XY34, ab12, PQ99",
        "Messy chunk: [AB12]\tAB12\nMN45 + zZ88",
        "Other noise: 1234 ABCD A1B2"
      ].join("\n");

      resetPattern();
      // Demo pattern: Letter, Letter, Number, Number => picks values like AB12, XY34.
      const row = patternRows[0];
      row.cells[0].select.value = TYPE.LETTER;
      row.cells[1].select.value = TYPE.LETTER;
      row.cells[2].select.value = TYPE.NUMBER;
      row.cells[3].select.value = TYPE.NUMBER;
      el.lengthAuto.checked = false;
      el.manualLength.disabled = false;
      el.manualLength.value = "4";
      el.presetSelect.value = "";
      setHeaderNameByPatternSource("sample");
      validatePattern(true);
      setStatus("Sample loaded. Click Extract.", "ok");
    }

    function wireEvents() {
      el.lengthAuto.addEventListener("change", () => {
        el.manualLength.disabled = el.lengthAuto.checked;
        setHeaderNameByPatternSource("custom");
        validatePattern(false);
      });
      el.manualLength.addEventListener("input", () => {
        setHeaderNameByPatternSource("custom");
        validatePattern(false);
      });
      el.extractBtn.addEventListener("click", extractMatches);
      el.copyOutputBtn.addEventListener("click", copyOutput);
      el.clearInputBtn.addEventListener("click", () => {
        el.inputText.value = "";
        setStatus("Input cleared.", "");
      });
      el.clearOutputBtn.addEventListener("click", () => {
        el.outputText.value = "";
        el.countTotal.textContent = "0";
        el.countUnique.textContent = "0";
        el.countTime.textContent = "0 ms";
        setStatus("Output cleared.", "");
      });
      el.resetPatternBtn.addEventListener("click", resetPattern);
      el.sampleBtn.addEventListener("click", loadSample);
      el.addPatternRowBtn.addEventListener("click", () => {
        addPatternRow();
        el.presetSelect.value = "";
        setHeaderNameByPatternSource("custom");
      });
      el.presetSelect.addEventListener("change", () => {
        if (el.presetSelect.value) {
          applyPreset(el.presetSelect.value);
        } else {
          setHeaderNameByPatternSource("custom");
        }
      });
      el.layoutSelect.addEventListener("change", () => {
        const withHeader = el.layoutSelect.value === "singleColumnWithHeader";
        el.headerName.disabled = !withHeader;
      });
    }

    addPatternRow("", true);
    initTheme();
    wireThemeMessages();
    wireEvents();
    setHeaderNameByPatternSource("custom");
    el.layoutSelect.dispatchEvent(new Event("change"));
    validatePattern(false);
  </script>
</body>
</html>
